// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */
enum Role {
  SUPERADMIN
  ADMIN
  AGENT
  STUDENT
}

enum Status {
  ACTIVE
  SUSPENDED
  INVITED
}

enum StudentKycStatus {
  NOT_STARTED
  SUBMITTED
  VERIFIED
  FAILED
}

enum PayoutMethod {
  BANK
  MPESA
}

enum UnitPref {
  IMPERIAL
  METRIC
}

enum AdminScope {
  SUPERADMIN
  ADMIN
  ANALYST
  READONLY
}

enum BookingStatus {
  PENDING_PAYMENT
  PAYMENT_COMPLETE
  READY_TO_SUBMIT
  UNDER_REVIEW
  APPROVED
  REJECTED
  CANCELLED
}

enum BookingPayMethod {
  CARD
  MPESA
}

enum OfferStatus {
  SENT
  ACCEPTED
  DECLINED
  EXPIRED
  CANCELLED
}

enum AgentKycStatus {
  PENDING
  PASSED
  FAILED
}

/**
 * ===== Models =====
 */
model User {
  id           String    @id @default(uuid())
  email        String    @unique
  name         String?
  passwordHash String
  role         Role      @default(STUDENT)
  status       Status    @default(ACTIVE)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  deletedAt    DateTime?

  phone   String?
  school  String?
  program String?

  adminScope         AdminScope?
  twoFA              Boolean     @default(false)
  apiKey             String?
  tokenVersion       Int         @default(0)
  mustChangePassword Boolean     @default(false)
  invitedAt          DateTime?
  lastLoginAt        DateTime?

  studentProfile StudentProfile? @relation("UserStudentProfile")
  agentProfile   AgentProfile?   @relation("UserAgentProfile")

  listings        Listing[] // agent’s listings (back to Listing.agent)
  studentBookings Booking[] // student’s bookings
  studentDocs     StudentDoc[]
  agentDocs       AgentDoc[]

  // Offers
  agentOffers Offer[] @relation("UserAgentOffers")

  // ⬇️ NEW: back-relation for Listing.updatedBy
  updatedListings Listing[] @relation("ListingUpdatedBy")

  updatedAppSettings AppSetting[] @relation("AppSettingUpdatedBy")

  @@index([role, status])
}

model StudentProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation("UserStudentProfile", fields: [userId], references: [id], onDelete: Cascade)

  // Basics
  fullName    String?
  email       String?
  avatarUrl   String?
  dob         String?
  nationality String?
  passportNo  String?

  // Study
  school     String?
  program    String?
  intake     String?
  targetCity String?

  // Contact
  phone    String?
  whatsapp String?

  // Address
  addressLine1   String?
  addressLine2   String?
  addressCity    String?
  addressCountry String?
  postal         String?

  // Emergency
  emergencyName     String?
  emergencyRelation String?
  emergencyPhone    String?

  // Preferences
  commsEmail    Boolean? @default(false)
  commsSMS      Boolean? @default(false)
  commsWhatsApp Boolean? @default(false)

  // KYC + payments
  kycStatus      StudentKycStatus @default(NOT_STARTED)
  paymentMethods Json?

  adminNotes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AgentDoc {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  filename  String
  mime      String?
  size      Int
  url       String
  category  String?
  status    String? // "Pending" | "Verified" | "Rejected"
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

// Extend AgentProfile with KYC + notes + rating + avatar (optional but handy)
model AgentProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation("UserAgentProfile", fields: [userId], references: [id], onDelete: Cascade)

  // Person
  first String?
  last  String?
  email String?
  phone String?
  city  String?

  // Org
  orgName      String?
  website      String?
  supportEmail String?

  // Payouts
  payoutMethod  PayoutMethod @default(BANK)
  bankName      String?
  accountName   String?
  accountNumber String?
  branch        String?
  mpesaPhone    String?

  // Preferences
  prefsTimezone String?  @default("Africa/Nairobi")
  prefsCurrency String?  @default("USD")
  prefsUnit     UnitPref @default(IMPERIAL)

  // Notifications
  notifyNewInquiry   Boolean? @default(true)
  notifyDocUploaded  Boolean? @default(true)
  notifyOfferEmailed Boolean? @default(true)
  notifyPayoutPaid   Boolean? @default(true)
  notifyWeeklyDigest Boolean? @default(false)

  // Dev
  devWebhook String?

  // NEW
  kycStatus AgentKycStatus @default(PENDING)
  notes     String?
  rating    Float?         @default(0)
  avatarUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Listing {
  id      String @id @default(uuid())
  agentId String
  agent   User   @relation(fields: [agentId], references: [id], onDelete: Cascade)

  title      String
  type       String
  city       String
  university String?
  price      Int

  description String
  highlights  String[] @default([])
  amenities   String[] @default([])
  policies    String[] @default([])
  notes       String?

  address     String?
  latitude    String?
  longitude   String?
  transitMins String?

  furnished Boolean @default(false)
  verified  Boolean @default(false)

  // ⬇️ must be unique for a 1:1
  coverImageId String?       @unique
  coverImage   ListingImage? @relation("CoverImage", fields: [coverImageId], references: [id], onDelete: SetNull)

  // Moderation
  published    Boolean @default(true)
  featured     Boolean @default(false)
  needsReview  Boolean @default(false)
  reportsCount Int     @default(0)

  // Simple audit for “who last changed it” from admin tools
  updatedById String?
  updatedBy   User?   @relation("ListingUpdatedBy", fields: [updatedById], references: [id])

  // ⬇️ name the 1:N relation to avoid ambiguity
  images  ListingImage[]  @relation("ListingImages")
  units   ListingUnit[]
  reports ListingReport[]

  bookings Booking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([agentId, createdAt])
}

model ListingReport {
  id        String  @id @default(uuid())
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  reason        String?
  message       String?
  reporter      String? // name or id
  reporterEmail String?
  createdAt     DateTime @default(now())

  @@index([listingId])
}

model ListingImage {
  id String @id @default(uuid())

  listingId String
  listing   Listing @relation("ListingImages", fields: [listingId], references: [id], onDelete: Cascade)

  // ⬇️ opposite side of the 1:1; no fields/references here
  coverOf Listing? @relation("CoverImage")

  url    String
  path   String
  size   Int
  width  Int?
  height Int?
  order  Int    @default(0)

  createdAt DateTime @default(now())

  @@index([listingId, order])
}

// prisma/schema.prisma
model ListingUnit {
  id        String  @id @default(uuid())
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  label         String?
  type          String?
  price         Int?
  availableFrom String?
  leaseMonths   Int?
  size          String?

  // NEW
  availableCount Int? @default(0)

  @@index([listingId])
}

model Booking {
  id String @id @default(uuid())

  // who & what
  studentId String
  student   User   @relation(fields: [studentId], references: [id], onDelete: Cascade)

  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // dates are strings to match your FE today (YYYY-MM-DD)
  checkIn  String
  checkOut String

  note          String?
  docIds        String[]  @default([])
  docsUpdatedAt DateTime?

  // fee + submission
  applicationFeeCents Int               @default(2500)
  paymentMethod       BookingPayMethod?
  feePaidAt           DateTime?
  submittedAt         DateTime?

  status BookingStatus @default(PENDING_PAYMENT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ⬇️ NEW: opposite side of Offer.booking
  offers Offer[] @relation("BookingOffers")

  @@index([studentId, createdAt])
  @@index([listingId, createdAt])
}

model StudentDoc {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  filename  String
  mime      String?
  size      Int
  url       String
  category  String?
  status    String? // ← add this
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model Offer {
  id String @id @default(uuid())

  // Booking relation (required, cascade on delete)
  bookingId String
  booking   Booking @relation("BookingOffers", fields: [bookingId], references: [id], onDelete: Cascade)

  // Agent relation (optional so SetNull is valid)
  agentId String?
  agent   User?   @relation("UserAgentOffers", fields: [agentId], references: [id], onDelete: SetNull)

  status   OfferStatus @default(SENT)
  currency String      @default("USD")
  note     String?
  lines    Json // [{label, amountCents, dueType, dueDate?}]

  sentAt     DateTime  @default(now())
  expiresAt  DateTime?
  acceptedAt DateTime?
  declinedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId, status])
  @@index([agentId, createdAt])
}

model AppSetting {
  /// always a single row with id "GLOBAL"
  id          String   @id @default("GLOBAL")
  data        Json
  updatedAt   DateTime @updatedAt
  updatedById String?
  updatedBy   User?    @relation("AppSettingUpdatedBy", fields: [updatedById], references: [id])
}
